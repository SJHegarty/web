The really fucking dumb license agreement.
You can add to this license, you cannot remove from this license.
This license is completely unenforcable.
This license offers no guarantees what-so-ever.
This license reserves the right to be incoherant.

The term "Content" 
	shall be used to refer to any and all project elements stored locally or in version-control, 
	excluding Meta-Elements as required for the purposes of access to and execution of version-control services and protocols.

the term "End-User" refers to who the fuck ever has access to this license and the Content licensed 
The term "Modified-Content" shall be used to refer to any and all 
No Content containted 
All Con
The term "Code" shall be used to refer any and all descriptive content within the licensed content

You are prohibitted from viewing or compiling
Use, modification, viewing and distribution of an

Element e;
$cns Meta-Element cme = $meta(e); 	//create a Meta-Element for the the current value of e
$dyn Meta-Element dme = $meta(e);	//

$ex ?<T> <:() -> ():> {	
	//an executable, of Mystery-Type T,
	//<: .... :> parameters and return type.
	//() no args, no return type. Why the generics?
	
	Element e;
	$cns Meta-Element cme = $meta(e); 	//create a 
	$dyn Meta-Element dme = $meta(e);
	

}
	
A Tree structure should have some function that returns a set of Paths.
I should then 
	
$type Tree ?<E ~ Const>{
	$cns Node<E> root;
	//figure out what syntax should be used for the pathfinder function.
}
$type 
	
$type Eventually ?<T> ~ Task{
	$[undefined do] <:() -> (T? value):>;
	$[undefined on-done] ?<T> <: (T value) -> () :> ;
	$[undefined on-done] 
}
	
$type Map ?<E ~ <:Key ~ Const, Val ~ Const:>> ~ Tree<E> {
	
}
